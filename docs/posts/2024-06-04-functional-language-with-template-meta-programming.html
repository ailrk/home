<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">

        <title>ailrk - Functional language with template meta programming</title>
        
          <link rel="preload" as="image" href="../images/sicp-anime1.jpg">

        

        <link rel="preload" href="./fonts/CrimsonPro-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
        <link rel="preload" href="./fonts/PTMono-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">

        <link rel="stylesheet" type="text/css" href="../style.css?v=0">
        <link rel="icon" type="image/x-icon" href="../favicon.ico">

        <!-- Metadata. -->
        <meta name="description" content="Airlk's personal blog">
        <meta property="og:description" content />
    </head>
    <body>
        <div id="navigation">
            <h1></h1>
            <img id="avatar" src="../images/me.png" />
            <a href="../">home</a>
            <a href="https://github.com/ailrk">github</a>
            <a href="../About.html">about</a>
        </div>

        <div id="content">
    <div id="post">

    <h1>Functional language with template meta programming</h1>
    <div>
        
        <br />
        <i>Published on June  4, 2024 under the tag <a title="All pages tagged 'c++'." href="../tags/c%2B%2B.html" rel="tag">c++</a></i>
        <br />
        <br />
    </div>

    <p><img src="../images/sicp-anime1.jpg" /></p>
<hr />
<p>We have all heard that C++ template metaprogramming is essentially functional programming, but how functional is it really? Let’s find out!</p>
<p>In this article, I will use C++ templates as a programming language to implement an interpreter for a simple functional language called skibid-lang, which includes a reasonable set of features. This implementation is similar to the meta-circular interpreter in SICP.</p>
<p>Ok, let’s begin!</p>
<h3 id="warm-up">Warm up</h3>
<p>Let’s start with some simple utilities. Below is the definition of an identity function. Since we are operating at the type level, <code>struct</code> will be used as our function to map from type to type. Here we define a <code>struct</code> that takes a type <code>T</code> and returns the type <code>T</code>. The full evaluation is <code>identity&lt;T&gt;::type</code>. Note that a C++ type is a value in skibid-lang, and skibid-lang itself is duck typed, just like the template.</p>
<h5 id="identity">Identity</h5>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> identity <span class="op">{</span> <span class="kw">using</span> type <span class="op">=</span> T<span class="op">;</span> <span class="op">};</span></span></code></pre></div>
<p>To handle all variables in a uniform manner, all values in skibid-lang are <code>struct</code>s and are subclassed from <code>template &lt;typename T&gt; struct identity</code>. This ensures that we can always consult the <code>::type</code>, regardless of the value. This also means skibid-lang values are lazy and need to be explicitly evaluated.</p>
<p><em>Convention 1: Any skibid-lang value always contains a <code>::type</code> attribute</em></p>
<h5 id="quotes-unquotes">Quotes &amp; unquotes</h5>
<p>Quotes allow you to control when an expression is evaluated. For example, <code>identity&lt;int&gt;::type</code> will be evaluated to <code>int</code>, but <code>quote&lt;identity&lt;int&gt;::type&gt;</code> is just a <code>quote</code> and can be passed around. To retrieve the value, you can use <code>unquote&lt;quote&lt;identity&lt;int&gt;&gt;&gt;::type</code>, which cancels out the <code>quote</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> quote <span class="op">:</span> identity<span class="op">&lt;</span>quote<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span> <span class="op">{};</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> unquote<span class="op">&lt;</span>quote<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span> <span class="op">:</span> T <span class="op">{};</span></span></code></pre></div>
<h5 id="eval">Eval</h5>
<p>We write an <code>eval</code> helper so we don’t need to write <code>::type</code> all the time. This technique is commonly seen in template libraries as well.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> eval <span class="op">:</span> T<span class="op">::</span>type <span class="op">{};</span></span></code></pre></div>
<h3 id="values">Values</h3>
<p>Let’s define some data types for the language. C++ supports basic types like <code>int</code> and <code>bool</code> directly at the type level. We will try to reuse as much of C++ as possible to avoid implementing these types ourselves.</p>
<h5 id="integer">Integer</h5>
<p>The following is the data constructor for a type-level integer. It’s defined as a skibid-lang type with the additional <code>::value</code> attribute. <code>::value</code> is used to retrieve the constant value from a skibid-lang value.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">int</span> N<span class="op">&gt;</span> <span class="kw">struct</span> <span class="va">int_</span> <span class="op">:</span> identity<span class="op">&lt;</span><span class="va">int_</span><span class="op">&lt;</span>N<span class="op">&gt;&gt;</span> <span class="op">{</span> <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> value <span class="op">=</span> N<span class="op">;</span> <span class="op">};</span></span></code></pre></div>
<p><em>Convention 2: A skibidi constant has a <code>::value</code> attribute</em></p>
<p>Here are some arithmetic operations for integers. Instead of implementing them within skibid-lang, we take the shortcut and reuse C++ facilities directly. Here we simply created some skibid-lang functions, unwrap parameters to retrieve the C++ integer from arguments, and perform C++ arithmetic operations. A skibid-lang function always comes with an <code>::apply</code> attribute that should be templated with some parameters.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> plus <span class="op">:</span> identity<span class="op">&lt;</span>plus<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> B<span class="op">&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> apply <span class="op">=</span> <span class="va">int_</span><span class="op">&lt;</span>A<span class="op">::</span>type<span class="op">::</span>value <span class="op">+</span> B<span class="op">::</span>type<span class="op">::</span>value<span class="op">&gt;;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> minus <span class="op">:</span> identity<span class="op">&lt;</span>minus<span class="op">&gt;</span> <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> times <span class="op">:</span> identity<span class="op">&lt;</span>times<span class="op">&gt;</span> <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span></code></pre></div>
<p>Now we can perform basic arithmetic with these operations. For instance, <code>plus::apply&lt;int_&lt;1&gt;, int_&lt;2&gt;&gt;::type::value</code> should evaluate to <code>int_&lt;3&gt;</code>.</p>
<p><em>Convention 3: A skibidi function has a <code>::apply</code> attribute that takes some arguments and evaluates to some other skibidi value</em></p>
<p>We can use the following helper to perform application instead of manually accessing <code>::apply</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> F<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span> <span class="kw">struct</span> apply <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> type <span class="op">=</span> <span class="kw">typename</span> F<span class="op">::</span><span class="kw">template</span> apply<span class="op">&lt;</span>Ts<span class="op">...&gt;::</span>type<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h5 id="boolean">Boolean</h5>
<p>Boolean is defined in a similar way.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">bool</span> N<span class="op">&gt;</span> <span class="kw">struct</span> <span class="va">bool_</span> <span class="op">:</span> identity<span class="op">&lt;</span><span class="va">bool_</span><span class="op">&lt;</span>N<span class="op">&gt;&gt;</span> <span class="op">{</span> <span class="at">static</span> <span class="at">const</span> <span class="dt">bool</span> value <span class="op">=</span> N<span class="op">;</span> <span class="op">};</span></span></code></pre></div>
<p>We define <code>not_</code> using template specialization. First, we declare the function <code>not_</code>, and then we add cases for it. Each specialization is like a branch in pattern matching, and the inheritance here serves as a return. Since <code>bool_</code> is already a skibid-lang value, we don’t need to define <code>::type</code> for <code>not_</code> again.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> <span class="va">not_</span><span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;&gt;</span> <span class="kw">struct</span> <span class="va">not_</span><span class="op">&lt;</span><span class="va">bool_</span><span class="op">&lt;</span><span class="kw">true</span><span class="op">&gt;&gt;</span> <span class="op">:</span> <span class="va">bool_</span><span class="op">&lt;</span><span class="kw">false</span><span class="op">&gt;</span> <span class="op">{};</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;&gt;</span> <span class="kw">struct</span> <span class="va">not_</span><span class="op">&lt;</span><span class="va">bool_</span><span class="op">&lt;</span><span class="kw">false</span><span class="op">&gt;&gt;</span> <span class="op">:</span> <span class="va">bool_</span><span class="op">&lt;</span><span class="kw">true</span><span class="op">&gt;</span> <span class="op">{};</span></span></code></pre></div>
<p><code>and_</code> and <code>or_</code> are variadic templates. You can also make them binary operations, but the template syntax is already quite cluttered, so the fewer angle brackets, the better for us.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> <span class="va">and_</span> <span class="op">:</span> <span class="va">bool_</span><span class="op">&lt;(</span>Ts<span class="op">::</span>type<span class="op">::</span>value <span class="op">&amp;&amp;</span> <span class="op">...</span> <span class="op">&amp;&amp;</span> <span class="kw">true</span><span class="op">)&gt;</span> <span class="op">{};</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> <span class="va">or_</span> <span class="op">:</span> <span class="va">bool_</span><span class="op">&lt;(</span>Ts<span class="op">::</span>type<span class="op">::</span>value <span class="op">||</span> <span class="op">...</span> <span class="op">||</span> <span class="kw">false</span><span class="op">)&gt;</span> <span class="op">{};</span></span></code></pre></div>
<h5 id="ordering-on-integer">Ordering on integer</h5>
<p>With boolean and integer defined, we can implement some ordering operations for integers as follows:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> less_equal <span class="op">:</span> identity<span class="op">&lt;</span>less_equal<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> B<span class="op">&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> apply <span class="op">=</span> <span class="va">bool_</span><span class="op">&lt;(</span>A<span class="op">::</span>type<span class="op">::</span>value <span class="op">&lt;=</span> B<span class="op">::</span>type<span class="op">::</span>value<span class="op">)&gt;;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> less <span class="op">:</span> identity<span class="op">&lt;</span>less<span class="op">&gt;</span> <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> greater <span class="op">:</span> identity<span class="op">&lt;</span>greater<span class="op">&gt;</span> <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> greater_equal <span class="op">:</span> identity<span class="op">&lt;</span>greater_equal<span class="op">&gt;</span> <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span></code></pre></div>
<p>This gives us the foundation to implemnet conditional later.</p>
<h5 id="list">List</h5>
<p>Let’s define a type level list. First we need two constructors <code>cons</code> and <code>nil</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> H<span class="op">,</span> <span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> cons <span class="op">:</span> identity<span class="op">&lt;</span>cons<span class="op">&lt;</span>H<span class="op">,</span> T<span class="op">&gt;&gt;</span> <span class="op">{};</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> nil <span class="op">:</span> identity<span class="op">&lt;</span>nil<span class="op">&gt;</span> <span class="op">{};</span></span></code></pre></div>
<p>It’s pretty straightforward to work with this type of list in templates. We can use template specialization to deconstruct the <code>cons</code> constructor and work with the head and tail individually. Since specialization can be recursive, we can write recursive functions to work on the entire list.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> L<span class="op">,</span> <span class="kw">typename</span> R<span class="op">&gt;</span> <span class="kw">struct</span> append<span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> R<span class="op">&gt;</span> <span class="kw">struct</span> append<span class="op">&lt;</span>nil<span class="op">,</span> R<span class="op">&gt;</span> <span class="op">:</span> R <span class="op">{};</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> H<span class="op">,</span> <span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> R<span class="op">&gt;</span> <span class="kw">struct</span> append<span class="op">&lt;</span>cons<span class="op">&lt;</span>H<span class="op">,</span> T<span class="op">&gt;,</span> R<span class="op">&gt;</span> <span class="op">:</span> cons<span class="op">&lt;</span>H<span class="op">,</span> append<span class="op">&lt;</span>T<span class="op">,</span> R<span class="op">&gt;&gt;</span> <span class="op">{};</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> last<span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;&gt;</span> <span class="kw">struct</span> last<span class="op">&lt;</span>nil<span class="op">&gt;</span> <span class="op">:</span> nil <span class="op">{};</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> N<span class="op">&gt;</span> <span class="kw">struct</span> last<span class="op">&lt;</span>cons<span class="op">&lt;</span>N<span class="op">,</span> nil<span class="op">&gt;&gt;</span> <span class="op">:</span> N <span class="op">{};</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> N<span class="op">&gt;</span> <span class="kw">struct</span> last<span class="op">&lt;</span>cons<span class="op">&lt;</span>T<span class="op">,</span> N<span class="op">&gt;&gt;</span> <span class="op">:</span> last<span class="op">&lt;</span>N<span class="op">&gt;</span> <span class="op">{};</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> length<span class="op">;</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;&gt;</span> <span class="kw">struct</span> length<span class="op">&lt;</span>nil<span class="op">&gt;</span> <span class="op">:</span> <span class="va">int_</span><span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;</span> <span class="op">{};</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> N<span class="op">,</span> <span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> length<span class="op">&lt;</span>cons<span class="op">&lt;</span>N<span class="op">,</span> T<span class="op">&gt;&gt;</span> <span class="op">:</span> apply<span class="op">&lt;</span>plus<span class="op">,</span> <span class="va">int_</span><span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;,</span> length<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span> <span class="op">{};</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> null <span class="op">:</span> <span class="va">bool_</span><span class="op">&lt;</span><span class="kw">false</span><span class="op">&gt;</span> <span class="op">{};</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;&gt;</span> <span class="kw">struct</span> null<span class="op">&lt;</span>nil<span class="op">&gt;</span> <span class="op">:</span> <span class="va">bool_</span><span class="op">&lt;</span><span class="kw">true</span><span class="op">&gt;</span> <span class="op">{};</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> F<span class="op">,</span> <span class="kw">typename</span> L<span class="op">&gt;</span> <span class="kw">struct</span> map<span class="op">;</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> F<span class="op">&gt;</span> <span class="kw">struct</span> map<span class="op">&lt;</span>F<span class="op">,</span> nil<span class="op">&gt;</span> <span class="op">:</span> nil <span class="op">{};</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> F<span class="op">,</span> <span class="kw">typename</span> H<span class="op">,</span> <span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> map<span class="op">&lt;</span>F<span class="op">,</span> cons<span class="op">&lt;</span>H<span class="op">,</span> T<span class="op">&gt;&gt;</span> <span class="op">:</span> cons<span class="op">&lt;</span>apply<span class="op">&lt;</span>F<span class="op">,</span> H<span class="op">&gt;,</span> map<span class="op">&lt;</span>F<span class="op">,</span> T<span class="op">&gt;&gt;{</span> <span class="op">};</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> reverse<span class="op">;</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> S1<span class="op">,</span> <span class="kw">typename</span> S2<span class="op">&gt;</span> <span class="kw">struct</span> __reverse<span class="op">;</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> S2<span class="op">&gt;</span> <span class="kw">struct</span> __reverse<span class="op">&lt;</span>nil<span class="op">,</span> S2<span class="op">&gt;</span> <span class="op">:</span> S2 <span class="op">{};</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> H<span class="op">,</span> <span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> S2<span class="op">&gt;</span> <span class="kw">struct</span> __reverse<span class="op">&lt;</span>cons<span class="op">&lt;</span>H<span class="op">,</span> T<span class="op">&gt;,</span> S2<span class="op">&gt;</span> <span class="op">:</span> __reverse<span class="op">&lt;</span>T<span class="op">,</span> cons<span class="op">&lt;</span>H<span class="op">,</span> S2<span class="op">&gt;&gt;</span> <span class="op">{};</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> L<span class="op">&gt;</span> <span class="kw">struct</span> reverse <span class="op">:</span> __reverse<span class="op">&lt;</span>L<span class="op">,</span> nil<span class="op">&gt;</span> <span class="op">{};</span></span></code></pre></div>
<h3 id="conditional">Conditional</h3>
<p>The only conditional we need is <code>if ... then ... else ...</code>. The helper <code>if_impl</code> selects the skibidi value base on the condition.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> C<span class="op">,</span> <span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> F<span class="op">&gt;</span> <span class="kw">struct</span> <span class="va">if_</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">private</span><span class="op">:</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">bool</span> C_<span class="op">,</span> <span class="kw">typename</span> T_<span class="op">,</span> <span class="kw">typename</span> F_<span class="op">&gt;</span> <span class="kw">struct</span> if_impl<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T_<span class="op">,</span> <span class="kw">typename</span> F_<span class="op">&gt;</span> <span class="kw">struct</span> if_impl<span class="op">&lt;</span><span class="kw">true</span><span class="op">,</span> T_<span class="op">,</span> F_<span class="op">&gt;</span> <span class="op">:</span> T <span class="op">{};</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T_<span class="op">,</span> <span class="kw">typename</span> F_<span class="op">&gt;</span> <span class="kw">struct</span> if_impl<span class="op">&lt;</span><span class="kw">false</span><span class="op">,</span> T_<span class="op">,</span> F_<span class="op">&gt;</span> <span class="op">:</span> F <span class="op">{};</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> type <span class="op">=</span> <span class="kw">typename</span> if_impl<span class="op">&lt;</span>C<span class="op">::</span>type<span class="op">::</span>value<span class="op">,</span> T<span class="op">,</span> F<span class="op">&gt;::</span>type<span class="op">;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="variables">Variables?</h3>
<p>Variables are defined as arbitrary empty structs. For example, to use a variable <code>x</code>, we need to first define <code>struct x {};</code>, then wrap it as <code>var&lt;x&gt;</code>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Id<span class="op">&gt;</span> <span class="kw">struct</span> var <span class="op">:</span> identity<span class="op">&lt;</span>var<span class="op">&lt;</span>Id<span class="op">&gt;&gt;</span> <span class="op">{};</span></span></code></pre></div>
<p>Different from most languages, in skibid-lang, before using any variable, we need to declare them first. So if you have a lambda that uses an <code>x</code>, you need to have the following definition somewhere before the usage.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> <span class="va">x__</span> <span class="op">{};</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> x <span class="op">=</span> var<span class="op">&lt;</span><span class="va">x__</span><span class="op">&gt;;</span></span></code></pre></div>
<p>This is rather daunting, we can make it less painful with some macros.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define declare</span><span class="op">(</span>n<span class="op">)</span><span class="pp">                                                             </span><span class="op">\</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="pp">    </span><span class="kw">struct</span><span class="pp"> </span>n<span class="op">##</span>__tml__internal_defined_var_<span class="pp"> </span><span class="op">{};</span><span class="pp">                                 </span><span class="op">\</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="pp">    </span><span class="kw">using</span><span class="pp"> </span>n<span class="pp"> </span><span class="op">=</span><span class="pp"> </span>var<span class="op">&lt;</span>n<span class="op">##</span>__tml__internal_defined_var_<span class="op">&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="co">// we need to declare variables before being able to use them.</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>declare<span class="op">(</span>_v0<span class="op">);</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>declare<span class="op">(</span>_v1<span class="op">);</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>declare<span class="op">(</span>_v2<span class="op">);</span></span></code></pre></div>
<h3 id="let">Let</h3>
<p>The <code>let</code> binding comes in the form <code>let &lt;var&gt; = &lt;expr1&gt; in &lt;expr2&gt;</code>. To evaluate a <code>let</code> expression, we need to substitute the occurrence of <code>&lt;var&gt;</code> in the body <code>&lt;expr2&gt;</code> with <code>&lt;expr1&gt;</code>. To do so, we need to quote <code>&lt;expr1&gt;</code> and <code>&lt;expr2&gt;</code> to move them around during the substitution, and then unquote everything to evaluate the substituted <code>&lt;expr3&gt;</code>.</p>
<p>We now declare our substitution function for <code>let</code>. Here we have <code>let_subst_1</code> and <code>let_subst_2</code>, two functions, but they’re really just one function. The order of specialization matters; when there are multiple possible specializations, we want to prioritize some over others. <code>let_subst_1</code> acts like a filter; we only call <code>let_subst_2</code> after all specializations in <code>let_subst_1</code> have failed.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> E<span class="op">,</span> <span class="kw">typename</span> In<span class="op">&gt;</span> <span class="kw">struct</span> let_subst_1<span class="op">;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> E<span class="op">,</span> <span class="kw">typename</span> In<span class="op">&gt;</span> <span class="kw">struct</span> let_subst_2<span class="op">;</span></span></code></pre></div>
<p>This case interfere with <code>let_subst_2&lt;_A, _E, quote&lt;V&gt;&gt;</code>, so we pick <code>V</code> out of the quote it here.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> E<span class="op">,</span> <span class="kw">typename</span> V<span class="op">&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> let_subst_1<span class="op">&lt;</span>A<span class="op">,</span> E<span class="op">,</span> unquote<span class="op">&lt;</span>quote<span class="op">&lt;</span>V<span class="op">&gt;&gt;&gt;</span> <span class="op">:</span> let_subst_1<span class="op">&lt;</span>A<span class="op">,</span> E<span class="op">,</span> V<span class="op">&gt;</span> <span class="op">{};</span></span></code></pre></div>
<p>For expressions like <code>let x = y in x</code>, y is .redundant and can be discarded.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> E<span class="op">&gt;</span> <span class="kw">struct</span> let_subst_1<span class="op">&lt;</span>A<span class="op">,</span> E<span class="op">,</span> A<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> type <span class="op">=</span> E<span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>With all cases above out of the way, we move into <code>let_subst_2</code>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> E<span class="op">,</span> <span class="kw">typename</span> In<span class="op">&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> let_subst_1 <span class="op">:</span> let_subst_2<span class="op">&lt;</span>A<span class="op">,</span> E<span class="op">,</span> In<span class="op">&gt;</span> <span class="op">{};</span></span></code></pre></div>
<p><code>let_subst_2</code> contains the full substitution.</p>
<p>If the body is quoted don’t touch it quoted.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> _A<span class="op">,</span> <span class="kw">typename</span> _E<span class="op">,</span> <span class="kw">typename</span> V<span class="op">&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> let_subst_2<span class="op">&lt;</span>_A<span class="op">,</span> _E<span class="op">,</span> quote<span class="op">&lt;</span>V<span class="op">&gt;&gt;</span> <span class="op">:</span> quote<span class="op">&lt;</span>V<span class="op">&gt;</span> <span class="op">{};</span></span></code></pre></div>
<p>If right-hand side expression is an application, we substitute left-hand side expression to the body of every arguments.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> E<span class="op">,</span> <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...&gt;</span> <span class="kw">typename</span> F<span class="op">,</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> let_subst_2<span class="op">&lt;</span>A<span class="op">,</span> E<span class="op">,</span> F<span class="op">&lt;</span>Ts<span class="op">...&gt;&gt;</span> <span class="op">{</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> type <span class="op">=</span> F<span class="op">&lt;</span><span class="kw">typename</span> let_subst_1<span class="op">&lt;</span>A<span class="op">,</span> E<span class="op">,</span> Ts<span class="op">&gt;::</span>type<span class="op">...&gt;;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Finally, we simply evaluate the let body.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> _A<span class="op">,</span> <span class="kw">typename</span> _E<span class="op">,</span> <span class="kw">typename</span> In<span class="op">&gt;</span> <span class="kw">struct</span> let_subst_2 <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> type <span class="op">=</span> In<span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>We define a new helper <code>strict_let</code> that extracts quoted <code>E</code> and <code>In</code>, call <code>let_subst_1</code> on it, and evaluates the resulted expression. We quote the result so during the substitution the evaluation is not performed. If we want to get the value back we can simply unquote the whole thing.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> E<span class="op">,</span> <span class="kw">typename</span> In<span class="op">&gt;</span> <span class="kw">struct</span> strict_let<span class="op">;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> E<span class="op">,</span> <span class="kw">typename</span> In<span class="op">&gt;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> strict_let<span class="op">&lt;</span>A<span class="op">,</span> quote<span class="op">&lt;</span>E<span class="op">&gt;,</span> quote<span class="op">&lt;</span>In<span class="op">&gt;&gt;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span> quote<span class="op">&lt;</span><span class="kw">typename</span> let_subst_1<span class="op">&lt;</span>A<span class="op">,</span> E<span class="op">,</span> In<span class="op">&gt;::</span>type<span class="op">&gt;</span> <span class="op">{};</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> E<span class="op">,</span> <span class="kw">typename</span> In<span class="op">&gt;</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> let_quoted <span class="op">:</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    strict_let<span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">::</span>type<span class="op">,</span> <span class="kw">typename</span> E<span class="op">::</span>type<span class="op">,</span> <span class="kw">typename</span> In<span class="op">::</span>type<span class="op">&gt;</span> <span class="op">{};</span></span></code></pre></div>
<p>Finally we tight everything together to make <code>let</code>. <code>let</code> only have specialization when <code>In</code> is <code>in</code> so this forces us to use the <code>let ... in ...</code> syntax. <code>let</code> specializes to <code>unquote&lt;typename let_quoted&lt;A, quoted&lt;E&gt;, quote&lt;In&gt;&gt;&gt;</code>, it unquotes the quote added put by <code>strict_let</code>.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> In<span class="op">&gt;</span> <span class="kw">struct</span> in <span class="op">:</span> In <span class="op">{};</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> E<span class="op">,</span> <span class="kw">typename</span> In<span class="op">&gt;</span> <span class="kw">struct</span> let<span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> E<span class="op">,</span> <span class="kw">typename</span> In<span class="op">&gt;</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> let<span class="op">&lt;</span>A<span class="op">,</span> E<span class="op">,</span> in<span class="op">&lt;</span>In<span class="op">&gt;&gt;</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span> unquote<span class="op">&lt;</span><span class="kw">typename</span> let_quoted<span class="op">&lt;</span>A<span class="op">,</span> quote<span class="op">&lt;</span>E<span class="op">&gt;,</span> quote<span class="op">&lt;</span>In<span class="op">&gt;&gt;::</span>type<span class="op">&gt;</span> <span class="op">{};</span></span></code></pre></div>
<p>We use let like this:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>let<span class="op">&lt;</span>x<span class="op">,</span> <span class="va">int_</span><span class="op">&lt;</span><span class="dv">10</span><span class="op">&gt;,</span> in <span class="op">&lt;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>let<span class="op">&lt;</span>y<span class="op">,</span> <span class="va">int_</span><span class="op">&lt;</span><span class="dv">20</span><span class="op">&gt;,</span> in <span class="op">&lt;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    y<span class="op">&gt;&gt;&gt;&gt;;</span></span></code></pre></div>
<h3 id="lambda">Lambda</h3>
<p>lambda is represented as a pair of parameter list and quoted body expression. The implementation is very similar to <code>let</code>. Actually we can always convert a let expression <code>let x = &lt;expr&gt;  in &lt;expr&gt;</code> into <code>(\x -&gt; &lt;expr&gt;) &lt;expr&gt;</code>. Because the implementation is so close, I will not explain as detailed as the <code>let</code> section.</p>
<p>We have the similar mutual recursive substitution functions as <code>let</code>.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Body<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span> <span class="kw">struct</span> lambda_subst_1<span class="op">;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Body<span class="op">,</span> <span class="kw">typename</span><span class="op">...&gt;</span> <span class="kw">struct</span> lambda_subst_2<span class="op">;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Body<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> lambda_subst_1 <span class="op">:</span> lambda_subst_2<span class="op">&lt;</span>Body<span class="op">,</span> Ts<span class="op">...&gt;</span> <span class="op">{};</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Body<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> lambda_subst_1<span class="op">&lt;</span>unquote<span class="op">&lt;</span>quote<span class="op">&lt;</span>Body<span class="op">&gt;&gt;,</span> Ts<span class="op">...&gt;</span> <span class="op">:</span> lambda_subst_1<span class="op">&lt;</span>Body<span class="op">,</span> Ts<span class="op">...&gt;</span> <span class="op">{</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Body<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> lambda_subst_2<span class="op">&lt;</span>quote<span class="op">&lt;</span>Body<span class="op">&gt;,</span> Ts<span class="op">...&gt;</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span> identity<span class="op">&lt;</span>lambda_subst_2<span class="op">&lt;</span>quote<span class="op">&lt;</span>Body<span class="op">&gt;,</span> Ts<span class="op">...&gt;&gt;</span> <span class="op">{</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> apply <span class="op">=</span> quote<span class="op">&lt;</span>Body<span class="op">&gt;;</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Body<span class="op">&gt;</span> <span class="kw">struct</span> lambda_subst_2<span class="op">&lt;</span>Body<span class="op">&gt;</span> <span class="op">:</span> Body <span class="op">{};</span></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Body<span class="op">,</span> <span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> lambda_subst_2<span class="op">&lt;</span>Body<span class="op">,</span> T<span class="op">,</span> Ts<span class="op">...&gt;</span> <span class="op">:</span> identity<span class="op">&lt;</span>lambda_subst_2<span class="op">&lt;</span>Body<span class="op">,</span> T<span class="op">,</span> Ts<span class="op">...&gt;&gt;</span> <span class="op">{</span></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> apply <span class="op">=</span> lambda_subst_1<span class="op">&lt;</span>let<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">,</span> in<span class="op">&lt;</span>Body<span class="op">&gt;&gt;,</span> Ts<span class="op">...&gt;;</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Like <code>let</code>, we need to handle quotes for lambda as well.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Body<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span> <span class="kw">struct</span> strict_lambda<span class="op">;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Body<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> strict_lambda<span class="op">&lt;</span>quote<span class="op">&lt;</span>Body<span class="op">&gt;,</span> Ts<span class="op">...&gt;</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span> quote<span class="op">&lt;</span><span class="kw">typename</span> lambda_subst_1<span class="op">&lt;</span>Body<span class="op">,</span> Ts<span class="op">...&gt;::</span>type<span class="op">&gt;</span> <span class="op">{};</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Body<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> lambda_quoted <span class="op">:</span> strict_lambda<span class="op">&lt;</span><span class="kw">typename</span> Body<span class="op">::</span>type<span class="op">,</span> <span class="kw">typename</span> Ts<span class="op">::</span>type<span class="op">...&gt;</span> <span class="op">{};</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span> <span class="kw">struct</span> lambda <span class="op">{</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Body<span class="op">&gt;</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> begin <span class="op">=</span> unquote<span class="op">&lt;</span><span class="kw">typename</span> lambda_quoted<span class="op">&lt;</span>quote<span class="op">&lt;</span>Body<span class="op">&gt;,</span> Ts<span class="op">...&gt;::</span>type<span class="op">&gt;;</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>We can now define lambdas like this:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>declare<span class="op">(</span>x<span class="op">);</span> declare<span class="op">(</span>y<span class="op">);</span> declare<span class="op">(</span>z<span class="op">);</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> func <span class="op">=</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    lambda<span class="op">&lt;</span>x<span class="op">,</span> y<span class="op">&gt;::</span>begin<span class="op">&lt;</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>        let<span class="op">&lt;</span>z<span class="op">,</span> <span class="va">int_</span><span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;,</span> in <span class="op">&lt;</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>            apply <span class="op">&lt;</span> plus<span class="op">,</span> apply <span class="op">&lt;</span>plus<span class="op">,</span> x<span class="op">,</span> y<span class="op">&gt;</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>                  <span class="op">,</span> apply <span class="op">&lt;</span>times<span class="op">,</span> z<span class="op">,</span> z<span class="op">&gt;</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>                  <span class="op">&gt;&gt;&gt;&gt;;</span></span></code></pre></div>
<h3 id="put-it-together">Put it together</h3>
<p>We have implemented a lot of features so far, let’s tight everything together and see how does skibidi-lang look like in action. The following program computes <code>10 - (3 + factorial(10))</code>.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>declare<span class="op">(</span>x<span class="op">);</span> declare<span class="op">(</span>y<span class="op">);</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> N<span class="op">&gt;</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> factorial <span class="op">:</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    <span class="va">if_</span> <span class="op">&lt;</span> apply <span class="op">&lt;</span>less<span class="op">,</span> N<span class="op">,</span> <span class="va">int_</span><span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;&gt;</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">,</span> <span class="va">int_</span><span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">,</span> apply <span class="op">&lt;</span>times<span class="op">,</span> factorial <span class="op">&lt;</span>apply <span class="op">&lt;</span>minus<span class="op">,</span> N<span class="op">,</span> <span class="va">int_</span><span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;&gt;&gt;,</span> N<span class="op">&gt;</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">&gt;</span> <span class="op">{};</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> plus3 <span class="op">=</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>        lambda<span class="op">&lt;</span>x<span class="op">&gt;::</span>begin</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">&lt;</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>               apply <span class="op">&lt;</span>plus<span class="op">,</span> x<span class="op">,</span> <span class="dv">3</span><span class="op">&gt;</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">&gt;</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> program <span class="op">=</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>    let <span class="op">&lt;</span>x<span class="op">,</span> factorial<span class="op">&lt;</span><span class="va">int_</span><span class="op">&lt;</span><span class="dv">10</span><span class="op">&gt;,</span> in <span class="op">&lt;</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>    let <span class="op">&lt;</span>y<span class="op">,</span> <span class="va">int_</span><span class="op">&lt;</span><span class="dv">10</span><span class="op">&gt;,</span>      in <span class="op">&lt;</span></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>        apply <span class="op">&lt;</span>minus<span class="op">,</span> y<span class="op">,</span> apply <span class="op">&lt;</span>plus3<span class="op">,</span> x<span class="op">&gt;&gt;</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">&gt;&gt;&gt;&gt;&gt;;</span></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a><span class="co">// output: -3628793</span></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main <span class="op">()</span> <span class="op">{</span></span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> program<span class="op">::</span>type<span class="op">::</span>value <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>It’s probably not the prettiest, definitely not the most practical, but I like how chaotic it is.</p>
<h3 id="conclusion">Conclusion</h3>
<p>That’s it! We’ve implemented a simple functional language interpreter using only C++ templates and functional programming techniques. While it’s not practical for real-world use, it’s a meaningful exercise to explore the power and flexibility of C++ templates. And the most important part is, it was tons of fun! The full code can be found on <a href="https://github.com/ailrk/skibidi-lang/blob/main/skibidi.hh">github</a></p>
</div>


    <div style="clear: both"></div>

    <div id="footer">
        Site proudly generated by
        <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
    </div>
</div>




        <!-- GUID -->
        <div style="display: none">ce0f13b2-4a83-4c1c-b2b9-b6d18f4ee6d2</div>
    </body>
</html>
